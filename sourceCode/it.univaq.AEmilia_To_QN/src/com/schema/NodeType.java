/**
 * NodeType.java
 *
 * This file was generated by XMLSPY 5 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package com.schema;

/**
 * Un Node (Nodo), il cui tipo è NodeType rappresenta una entitÃ  nell'ambiente
 * di esecuzione (execution environment)
 * del QueueingNetworkModel, che fornisce un servizio o è 
 * utile per designare la topologia del modello a reti di
 * code (come nel caso di SinkNode e SourceNode, che non
 * forniscono un servizio ma completano la topologia della
 * rete di code). Un nodo della rete può essere di tre tipi:
 * <br/>
 * - Server: Un Server rappresenta un nodo dell'execution
 * environment che fornisce un qualche tipo di servizio
 * (processing service) ai Workloads che gli fanno visita.
 * Il tempo di servizio non è specificato in quanto può
 * variare per classi di transazioni o jobs (Workloads).
 * <br/>
 * - WorkUnitServer: Un WorkUnitServer è un Server che dedica
 * lo stesso tempo di servizio (ServiceTime) a tutti i
 * Workloads che lo attraversano. Un WorkUnitServer è cioè
 * un Server che non è in grado di gestire le prioritÃ  tra
 * Workloads. Si può pensare ad esempio ad un Hard Disk che
 * ha un ben determinato tempo medio di accesso, e quindi,
 * nel caso che sia il sistema operativo o che sia
 * un'applicazione ad effettuare una richiesta di servizio,
 * il tempo di accesso ai dati non cambia. Mentre,
 * ad esempio, una CPU ha dei meccanismi interni tali da
 * garantire che certe applicazioni ad alta prioritÃ  (come
 * ad esempio il sistema operativo) siano eseguite piÃ¹
 * velocemente rispetto alle applicazioni utente a bassa
 * prioritÃ .
 * <br/>
 * - Non-ServerNode: Un Non-ServerNode (Nodo che non è un
 * Server) rappresenta un nodo dell'execution environment
 * utile solo al fine di completare la topologia del modello,
 * ma che non fornisce alcun tipo di servizio di
 * elaborazione.
 * <blockquote>
 * - SourceNode: Un SourceNode rappresenta un nodo
 * dell'execution environment che rappresenta l'origine di
 * un OpenWorkload, cioè il punto in cui è entrato nella rete
 * di code. Un SourceNode non fornisce alcun tipo di
 * elaborazione.
 * <br/>
 * - SinkNode: Un SinkNode rappresenta un nodo nel quale un
 * OpenWorkload termina il suo cammino, dopo aver ricevuto
 * servizio, uscendo da una rete di code.
 * Un SinkNode non fornisce alcun tipo di servizio.
 * </blockquote>
 * <pre>
 * <code>
 * &lt;xsd:complexType name="NodeType"&gt;
 * 	&lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
 * 		&lt;xsd:element name="Server" minOccurs="0" maxOccurs="unbounded"&gt;
 * 			&lt;xsd:complexType&gt;
 * 				&lt;xsd:attribute name="Name" type="xsd:ID" use="required"/&gt;
 * 				&lt;xsd:attribute name="Quantity" type="xsd:nonNegativeInteger" use="required"/&gt;
 * 				&lt;xsd:attribute name="SchedulingPolicy" type="SchedulingType" use="required"/&gt;
 * 			&lt;/xsd:complexType&gt;
 * 		&lt;/xsd:element&gt;
 * 		&lt;xsd:element name="WorkUnitServer" minOccurs="0" maxOccurs="unbounded"&gt;
 * 			&lt;xsd:complexType&gt;
 * 				&lt;xsd:attribute name="Name" type="xsd:ID" use="required"/&gt;
 * 				&lt;xsd:attribute name="Quantity" type="xsd:nonNegativeInteger" use="required"/&gt;
 * 				&lt;xsd:attribute name="SchedulingPolicy" type="SchedulingType" use="required"/&gt;
 * 				&lt;xsd:attribute name="TimeUnits" type="TimeUnitsType" use="optional"/&gt;
 * 				&lt;xsd:attribute name="ServiceTime" type="nonNegativeFloat" use="required"/&gt;
 * 			&lt;/xsd:complexType&gt;
 * 		&lt;/xsd:element&gt;
 * 		&lt;xsd:element name="SourceNode" minOccurs="0" maxOccurs="unbounded"&gt;
 * 			&lt;xsd:complexType&gt;
 * 				&lt;xsd:attribute name="Name" type="xsd:ID" use="required"/&gt;
 * 			&lt;/xsd:complexType&gt;
 * 		&lt;/xsd:element&gt;
 * 		&lt;xsd:element name="SinkNode" minOccurs="0" maxOccurs="unbounded"&gt;
 * 			&lt;xsd:complexType&gt;
 * 				&lt;xsd:attribute name="Name" type="xsd:ID" use="required"/&gt;
 * 			&lt;/xsd:complexType&gt;
 * 		&lt;/xsd:element&gt;
 * 	&lt;/xsd:choice&gt;
 * &lt;/xsd:complexType&gt;
 * </code>
 * </pre>
 * @author Mirko Email: <a href="mailto:mirkoflamminj@virgilio.it">mirkoflamminj@virgilio.it</a>
 * @version 1.0
 */
public class NodeType extends com.altova.xml.Node {

	private static final long serialVersionUID = 1L;

	public NodeType() {
		super();
	}

	public NodeType(org.w3c.dom.Node node) {
		super(node);
	}

	public int getServerCount() {
		return getDomChildCount(Element, null, "Server");
	}

	public boolean hasServer() {
		return hasDomChild(Element, null, "Server");
	}

	public ServerType getServerAt(int index) throws Exception {
		return new ServerType(getDomChildAt(Element, null, "Server", index));
	}

	public void addServer(ServerType value) {
		appendDomElement(null, "Server", value);
	}

	public int getWorkUnitServerCount() {
		return getDomChildCount(Element, null, "WorkUnitServer");
	}

	public boolean hasWorkUnitServer() {
		return hasDomChild(Element, null, "WorkUnitServer");
	}

	public WorkUnitServerType getWorkUnitServerAt(int index) throws Exception {
		return new WorkUnitServerType(getDomChildAt(Element, null, "WorkUnitServer", index));
	}

	public void removeWorkUnitServerAt(int index) {
		removeDomChildAt(Element, null, "WorkUnitServer", index);
	}

	public int getSourceNodeCount() {
		return getDomChildCount(Element, null, "SourceNode");
	}

	public boolean hasSourceNode() {
		return hasDomChild(Element, null, "SourceNode");
	}

	public SourceNodeType getSourceNodeAt(int index) throws Exception {
		return new SourceNodeType(getDomChildAt(Element, null, "SourceNode", index));
	}

	public void addSourceNode(SourceNodeType value) {
		appendDomElement(null, "SourceNode", value);
	}

	public int getSinkNodeCount() {
		return getDomChildCount(Element, null, "SinkNode");
	}

	public boolean hasSinkNode() {
		return hasDomChild(Element, null, "SinkNode");
	}

	public SinkNodeType getSinkNodeAt(int index) throws Exception {
		return new SinkNodeType(getDomChildAt(Element, null, "SinkNode", index));
	}

	public void addSinkNode(SinkNodeType value) {
		appendDomElement(null, "SinkNode", value);
	}
}
