/**
 * WorkUnitServerType.java
 *
 * This file was generated by XMLSPY 5 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package com.schema;

import com.altova.xml.types.SchemaID;
import com.altova.xml.types.SchemaInteger;

/**
 * Un WorkUnitServer Ë un Server che dedica lo stesso tempo
 * di servizio (ServiceTime) a tutti i Workloads che lo
 * attraversano. Un WorkUnitServer Ë cioË un Server che non
 * Ë in grado di gestire le priorit√† tra Workloads. Si puÚ
 * pensare ad esempio ad un Hard Disk che ha un ben
 * determinato tempo medio di accesso, e quindi, nel caso
 * che sia il sistema operativo o che sia un'applicazione
 * ad effettuare una richiesta di servizio, il tempo di
 * accesso ai dati non cambia. Mentre, ad esempio, una CPU
 * ha dei meccanismi interni tali da garantire che certe
 * applicazioni ad alta priorit√† (come ad esempio il sistema
 * operativo) siano eseguite pi√π velocemente rispetto alle
 * applicazioni utente a bassa priorit√†.
 * <pre>
 * <code>
 * &lt;xsd:element name="WorkUnitServer" minOccurs="0" maxOccurs="unbounded"&gt;
 * 	&lt;xsd:complexType&gt;
 * 		&lt;xsd:attribute name="Name" type="xsd:ID" use="required"/&gt;
 * 		&lt;xsd:attribute name="Quantity" type="xsd:nonNegativeInteger" use="required"/&gt;
 * 		&lt;xsd:attribute name="SchedulingPolicy" type="SchedulingType" use="required"/&gt;
 * 		&lt;xsd:attribute name="TimeUnits" type="TimeUnitsType" use="optional"/&gt;
 * 		&lt;xsd:attribute name="ServiceTime" type="nonNegativeFloat" use="required"/&gt;
 * 	&lt;/xsd:complexType&gt;
 * &lt;/xsd:element&gt;
 * </code>
 * </pre>
 *
 * @author Mirko Email: <a href="mailto:mirkoflamminj@virgilio.it">mirkoflamminj@virgilio.it</a>
 * @version 1.0
 */
public class WorkUnitServerType extends com.altova.xml.Node {

	private static final long serialVersionUID = 1L;

	public WorkUnitServerType() {
		super();
	}

	public WorkUnitServerType(WorkUnitServerType node) {
		super(node);
	}

	public WorkUnitServerType(org.w3c.dom.Node node) {
		super(node);
	}

	public WorkUnitServerType(org.w3c.dom.Document doc) {
		super(doc);
	}

	public int getNameMinCount() {
		return 1;
	}

	public int getNameMaxCount() {
		return 1;
	}

	public int getNameCount() {
		return getDomChildCount(Attribute, null, "Name");
	}

	public boolean hasName() {
		return hasDomChild(Attribute, null, "Name");
	}

	public SchemaID getNameAt(int index) throws Exception {
		return new SchemaID(getDomNodeValue(getDomChildAt(Attribute, null, "Name", index)));
	}

	public SchemaID getName() throws Exception {
		return getNameAt(0);
	}

	public void removeNameAt(int index) {
		removeDomChildAt(Attribute, null, "Name", index);
	}

	public void removeName() {
		while (hasName())
			removeNameAt(0);
	}

	public void addName(SchemaID value) {
		setDomChild(Attribute, null, "Name", value.toString());
	}

	public void addName(String value) throws Exception {
		addName(new SchemaID(value));
	}

	public void insertNameAt(SchemaID value, int index) {
		insertDomChildAt(Attribute, null, "Name", index, value.toString());
	}

	public void insertNameAt(String value, int index) throws Exception {
		insertNameAt(new SchemaID(value), index);
	}

	public void replaceNameAt(SchemaID value, int index) {
		replaceDomChildAt(Attribute, null, "Name", index, value.toString());
	}

	public void replaceNameAt(String value, int index) throws Exception {
		replaceNameAt(new SchemaID(value), index);
	}

	public int getQuantityMinCount() {
		return 1;
	}

	public int getQuantityMaxCount() {
		return 1;
	}

	public int getQuantityCount() {
		return getDomChildCount(Attribute, null, "Quantity");
	}

	public boolean hasQuantity() {
		return hasDomChild(Attribute, null, "Quantity");
	}

	public SchemaInteger getQuantityAt(int index) throws Exception {
		return new SchemaInteger(getDomNodeValue(getDomChildAt(Attribute, null, "Quantity", index)));
	}

	public SchemaInteger getQuantity() throws Exception {
		return getQuantityAt(0);
	}

	public void removeQuantityAt(int index) {
		removeDomChildAt(Attribute, null, "Quantity", index);
	}

	public void removeQuantity() {
		while (hasQuantity())
			removeQuantityAt(0);
	}

	public void addQuantity(SchemaInteger value) {
		setDomChild(Attribute, null, "Quantity", value.toString());
	}

	public void addQuantity(String value) throws Exception {
		addQuantity(new SchemaInteger(value));
	}

	public void insertQuantityAt(SchemaInteger value, int index) {
		insertDomChildAt(Attribute, null, "Quantity", index, value.toString());
	}

	public void insertQuantityAt(String value, int index) throws Exception {
		insertQuantityAt(new SchemaInteger(value), index);
	}

	public void replaceQuantityAt(SchemaInteger value, int index) {
		replaceDomChildAt(Attribute, null, "Quantity", index, value.toString());
	}

	public void replaceQuantityAt(String value, int index) throws Exception {
		replaceQuantityAt(new SchemaInteger(value), index);
	}

	public int getSchedulingPolicyMinCount() {
		return 1;
	}

	public int getSchedulingPolicyMaxCount() {
		return 1;
	}

	public int getSchedulingPolicyCount() {
		return getDomChildCount(Attribute, null, "SchedulingPolicy");
	}

	public boolean hasSchedulingPolicy() {
		return hasDomChild(Attribute, null, "SchedulingPolicy");
	}

	public SchedulingType getSchedulingPolicyAt(int index) throws Exception {
		return new SchedulingType(getDomNodeValue(getDomChildAt(Attribute, null, "SchedulingPolicy", index)));
	}

	public SchedulingType getSchedulingPolicy() throws Exception {
		return getSchedulingPolicyAt(0);
	}

	public void removeSchedulingPolicyAt(int index) {
		removeDomChildAt(Attribute, null, "SchedulingPolicy", index);
	}

	public void removeSchedulingPolicy() {
		while (hasSchedulingPolicy())
			removeSchedulingPolicyAt(0);
	}

	public void addSchedulingPolicy(SchedulingType value) {
		setDomChild(Attribute, null, "SchedulingPolicy", value.toString());
	}

	public void addSchedulingPolicy(String value) throws Exception {
		addSchedulingPolicy(new SchedulingType(value));
	}

	public void insertSchedulingPolicyAt(SchedulingType value, int index) {
		insertDomChildAt(Attribute, null, "SchedulingPolicy", index, value.toString());
	}

	public void insertSchedulingPolicyAt(String value, int index) throws Exception {
		insertSchedulingPolicyAt(new SchedulingType(value), index);
	}

	public void replaceSchedulingPolicyAt(SchedulingType value, int index) {
		replaceDomChildAt(Attribute, null, "SchedulingPolicy", index, value.toString());
	}

	public void replaceSchedulingPolicyAt(String value, int index) throws Exception {
		replaceSchedulingPolicyAt(new SchedulingType(value), index);
	}

	public int getTimeUnitsMinCount() {
		return 0;
	}

	public int getTimeUnitsMaxCount() {
		return 1;
	}

	public int getTimeUnitsCount() {
		return getDomChildCount(Attribute, null, "TimeUnits");
	}

	public boolean hasTimeUnits() {
		return hasDomChild(Attribute, null, "TimeUnits");
	}

	public TimeUnitsType getTimeUnitsAt(int index) throws Exception {
		return new TimeUnitsType(getDomNodeValue(getDomChildAt(Attribute, null, "TimeUnits", index)));
	}

	public TimeUnitsType getTimeUnits() throws Exception {
		return getTimeUnitsAt(0);
	}

	public void removeTimeUnitsAt(int index) {
		removeDomChildAt(Attribute, null, "TimeUnits", index);
	}

	public void removeTimeUnits() {
		while (hasTimeUnits())
			removeTimeUnitsAt(0);
	}

	public void addTimeUnits(TimeUnitsType value) {
		setDomChild(Attribute, null, "TimeUnits", value.toString());
	}

	public void addTimeUnits(String value) throws Exception {
		addTimeUnits(new TimeUnitsType(value));
	}

	public void insertTimeUnitsAt(TimeUnitsType value, int index) {
		insertDomChildAt(Attribute, null, "TimeUnits", index, value.toString());
	}

	public void insertTimeUnitsAt(String value, int index) throws Exception {
		insertTimeUnitsAt(new TimeUnitsType(value), index);
	}

	public void replaceTimeUnitsAt(TimeUnitsType value, int index) {
		replaceDomChildAt(Attribute, null, "TimeUnits", index, value.toString());
	}

	public void replaceTimeUnitsAt(String value, int index) throws Exception {
		replaceTimeUnitsAt(new TimeUnitsType(value), index);
	}

	public int getServiceTimeMinCount() {
		return 1;
	}

	public int getServiceTimeMaxCount() {
		return 1;
	}

	public int getServiceTimeCount() {
		return getDomChildCount(Attribute, null, "ServiceTime");
	}

	public boolean hasServiceTime() {
		return hasDomChild(Attribute, null, "ServiceTime");
	}

	public nonNegativeFloat getServiceTimeAt(int index) throws Exception {
		return new nonNegativeFloat(getDomNodeValue(getDomChildAt(Attribute, null, "ServiceTime", index)));
	}

	public nonNegativeFloat getServiceTime() throws Exception {
		return getServiceTimeAt(0);
	}

	public void removeServiceTimeAt(int index) {
		removeDomChildAt(Attribute, null, "ServiceTime", index);
	}

	public void removeServiceTime() {
		while (hasServiceTime())
			removeServiceTimeAt(0);
	}

	public void addServiceTime(nonNegativeFloat value) {
		setDomChild(Attribute, null, "ServiceTime", value.toString());
	}

	public void addServiceTime(String value) throws Exception {
		addServiceTime(new nonNegativeFloat(value));
	}

	public void insertServiceTimeAt(nonNegativeFloat value, int index) {
		insertDomChildAt(Attribute, null, "ServiceTime", index, value.toString());
	}

	public void insertServiceTimeAt(String value, int index) throws Exception {
		insertServiceTimeAt(new nonNegativeFloat(value), index);
	}

	public void replaceServiceTimeAt(nonNegativeFloat value, int index) {
		replaceDomChildAt(Attribute, null, "ServiceTime", index, value.toString());
	}

	public void replaceServiceTimeAt(String value, int index) throws Exception {
		replaceServiceTimeAt(new nonNegativeFloat(value), index);
	}
}
