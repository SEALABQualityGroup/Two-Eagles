/**
 * SchemaDateTime.java
 *
 * This file was generated by XMLSPY 5 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */

package pack.model.altova.xml.types;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class SchemaDateTime implements SchemaType {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private static final String format = "yyyy-MM-dd'T'HH:mm:ss";
	private static final String formatTZ = "yyyy-MM-dd'T'HH:mm:ssZ";
	private Calendar value;
	private boolean hasTZ;

	private static int stripMsec(StringBuffer sb) {
		if (sb.length() == 0 || sb.charAt(0) != '.')
			return 0;
		int i = 1;
		while (i < sb.length() && "0123456789".indexOf(sb.charAt(i)) != -1)
			i++;
		int msec = Math.round(Float.parseFloat(sb.substring(0, i)) * 1000);
		sb.delete(0, i);
		return msec;
	}

	private static String parseTZ(StringBuffer sb) {
		if (sb.length() == 1 && sb.charAt(0) == 'Z')
			return "+0000";
		else if (sb.length() == 6) // like "+01:00"
			return sb.substring(0, 3) + sb.substring(4, 6); // like "+0100"
		else
			return null;
	}

	private void parse(String newvalue) throws ParseException {
		int msec = 0;
		hasTZ = false;
		if (newvalue.length() > 19) {
			StringBuffer s = new StringBuffer(newvalue.substring(19));
			newvalue = newvalue.substring(0, 19);

			msec = stripMsec(s);
			String sTZ = parseTZ(s);
			if (sTZ != null) {
				hasTZ = true;
				newvalue += sTZ;
			}
		}
		value.setTime(new SimpleDateFormat(hasTZ ? formatTZ : format).parse(newvalue));
		if (msec != 0)
			value.set(Calendar.MILLISECOND, msec);
	}

	private SchemaDateTime(Calendar newvalue) {
		value = newvalue;
		hasTZ = true;
	}

	public SchemaDateTime(String newvalue) {
		try {
			value = Calendar.getInstance();
			parse(newvalue);
		} catch (ParseException e) {
			throw new pack.model.altova.xml.XmlException(e);
		}
	}

	public int hashCode() {
		return value.hashCode();
	}

	public boolean equals(Object obj) {
		if (!(obj instanceof SchemaDateTime))
			return false;
		return value.equals(((SchemaDateTime)obj).value);
	}

	public Object clone() {
		return new SchemaDateTime((Calendar)value.clone());
	}

	public String toString() {
		StringBuffer s = new StringBuffer(
				new SimpleDateFormat(format).format(value.getTime())
				);
		if (value.get(Calendar.MILLISECOND) != 0)
			s.append('.').append(new SimpleDateFormat("SSS").format(value.getTime()));
		if (hasTZ) {
			String tz = new SimpleDateFormat("Z").format(value.getTime()); // "+0100"
			s.append(tz.substring(0, 3));
			s.append(':');
			s.append(tz.substring(3, 5));
		}
		return s.toString();
	}

	public String asString() {
		return toString();
	}

	public int compareTo(Object obj) {
		return compareTo((SchemaDateTime)obj);
	}

	private int compareTo(SchemaDateTime obj) {
		return value.getTime().compareTo(obj.value.getTime());
	}
}
