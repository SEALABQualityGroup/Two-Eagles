/**
 * WorkloadType.java
 *
 * This file was generated by XMLSPY 5 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package pack.model.schema;


/**
 * Un Workload (carico di lavoro) rappresenta
 * un insieme di transazioni o jobs che	effettuano richieste
 * di servizio simili ai Servers di un QueueingNetworkModel.
 * Può essere di due tipi:
 * <br/>
 * 		- OpenWorkload: Un OpenWorkload (Carico di lavoro
 * 		"Aperto") è un Workload con una	popolazione
 * 		potenzialmente infinita, dove le transazioni
 * 		(transactions) o i job arrivano dal	mondo esterno
 * 		alla rete (attraverso un SourceNode), ricevono un
 * 		servizio dai nodi della	rete, e infine escono
 * 		(attraverso un SinkNode). La popolazione di un
 * 		OpenWorkload è, in ogni istante, variabile.
 * <br/>
 * 		- ClosedWorkload: Un ClosedWorkload (Carico di Lavoro
 * 		"Chiuso") è un Workload	(Carico di Lavoro) con una popolazione fissa che circola tra i Servers.
 *
 * <pre>
 * <code>
 * 	&lt;xsd:complexType name="WorkloadType"&gt;
 *		&lt;xsd:choice maxOccurs="unbounded"&gt;
 *			&lt;xsd:element name="OpenWorkload" minOccurs="0" maxOccurs="unbounded"&gt;
 *				&lt;xsd:complexType&gt;
 *					&lt;xsd:sequence&gt;
 *						&lt;xsd:element name="Transit" type="TransitType" maxOccurs="unbounded"/&gt;
 *					&lt;/xsd:sequence&gt;
 *					&lt;xsd:attribute name="WorkloadName" type="xsd:ID" use="required"/&gt;
 *					&lt;xsd:attribute name="ArrivalRate" type="nonNegativeFloat" use="required"/&gt;
 *					&lt;xsd:attribute name="TimeUnits" type="TimeUnitsType" use="optional"/&gt;
 *					&lt;xsd:attribute name="ArrivesAt" type="xsd:IDREF" use="required"/&gt;
 *					&lt;xsd:attribute name="DepartsAt" type="xsd:IDREF" use="required"/&gt;
 *				&lt;/xsd:complexType&gt;
 *			&lt;/xsd:element&gt;
 *			&lt;xsd:element name="ClosedWorkload" minOccurs="0" maxOccurs="unbounded"&gt;
 *				&lt;xsd:complexType&gt;
 *					&lt;xsd:sequence&gt;
 *						&lt;xsd:element name="Transit" type="TransitType" maxOccurs="unbounded"/&gt;
 *					&lt;/xsd:sequence&gt;
 *					&lt;xsd:attribute name="WorkloadName" type="xsd:ID" use="required"/&gt;
 *					&lt;xsd:attribute name="NumberOfJobs" type="xsd:nonNegativeInteger" use="required"/&gt;
 *					&lt;xsd:attribute name="ThinkTime" type="nonNegativeFloat" use="required"/&gt;
 *					&lt;xsd:attribute name="TimeUnits" type="TimeUnitsType" use="optional"/&gt;
 *					&lt;xsd:attribute name="ThinkDevice" type="xsd:IDREF" use="required"/&gt;
 *				&lt;/xsd:complexType&gt;
 *			&lt;/xsd:element&gt;
 *		&lt;/xsd:choice&gt;
 *	&lt;/xsd:complexType&gt;
 *
 * </code>
 * </pre>
 * @author Mirko Email: <a href="mailto:mirkoflamminj@virgilio.it">mirkoflamminj@virgilio.it</a>
 * @version 1.0
 */

public class WorkloadType 
	extends pack.model.altova.xml.Node 
	{

	private static final long serialVersionUID = 1L;
	
	public WorkloadType() {
		super();
	}

	public WorkloadType(WorkloadType node) {
		super(node);
	}

	public WorkloadType(org.w3c.dom.Node node) {
		super(node);
	}

	public WorkloadType(org.w3c.dom.Document doc) {
		super(doc);
	}

	public int getOpenWorkloadMinCount() {
		return 0;
	}

	public int getOpenWorkloadMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getOpenWorkloadCount() {
		return getDomChildCount(Element, null, "OpenWorkload");
	}

	public boolean hasOpenWorkload() {
		return hasDomChild(Element, null, "OpenWorkload");
	}

	public OpenWorkloadType getOpenWorkloadAt(int index) throws Exception {
		return new OpenWorkloadType(getDomChildAt(Element, null, "OpenWorkload", index));
	}

	public OpenWorkloadType getOpenWorkload() throws Exception {
		return getOpenWorkloadAt(0);
	}

	public void removeOpenWorkloadAt(int index) {
		removeDomChildAt(Element, null, "OpenWorkload", index);
	}

	public void removeOpenWorkload() {
		while (hasOpenWorkload())
			removeOpenWorkloadAt(0);
	}

	public void addOpenWorkload(OpenWorkloadType value) {
		appendDomElement(null, "OpenWorkload", value);
	}

	public void insertOpenWorkloadAt(OpenWorkloadType value, int index) {
		insertDomElementAt(null, "OpenWorkload", index, value);
	}

	public void replaceOpenWorkloadAt(OpenWorkloadType value, int index) {
		replaceDomElementAt(null, "OpenWorkload", index, value);
	}

	public int getClosedWorkloadMinCount() {
		return 0;
	}

	public int getClosedWorkloadMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getClosedWorkloadCount() {
		return getDomChildCount(Element, null, "ClosedWorkload");
	}

	public boolean hasClosedWorkload() {
		return hasDomChild(Element, null, "ClosedWorkload");
	}

	public ClosedWorkloadType getClosedWorkloadAt(int index) throws Exception {
		return new ClosedWorkloadType(getDomChildAt(Element, null, "ClosedWorkload", index));
	}

	public ClosedWorkloadType getClosedWorkload() throws Exception {
		return getClosedWorkloadAt(0);
	}

	public void removeClosedWorkloadAt(int index) {
		removeDomChildAt(Element, null, "ClosedWorkload", index);
	}

	public void removeClosedWorkload() {
		while (hasClosedWorkload())
			removeClosedWorkloadAt(0);
	}

	public void addClosedWorkload(ClosedWorkloadType value) {
		appendDomElement(null, "ClosedWorkload", value);
	}

	public void insertClosedWorkloadAt(ClosedWorkloadType value, int index) {
		insertDomElementAt(null, "ClosedWorkload", index, value);
	}

	public void replaceClosedWorkloadAt(ClosedWorkloadType value, int index) {
		replaceDomElementAt(null, "ClosedWorkload", index, value);
	}
	
	@Override
	public boolean equals(Object obj)
		{
		if (!(obj instanceof WorkloadType))
			return false;
		WorkloadType workloadType = (WorkloadType)obj;
		if (!this.hasOpenWorkload() && workloadType.hasOpenWorkload())
			return false;
		if (this.hasOpenWorkload() && !workloadType.hasOpenWorkload())
			return false;
		if (this.hasOpenWorkload() && workloadType.hasOpenWorkload())
			{
			if (this.getOpenWorkloadCount() != workloadType.getOpenWorkloadCount())
				return false;
			for (int i = 0; i < this.getOpenWorkloadCount(); i++)
				{
				try {
					if (!this.getOpenWorkloadAt(i).equals(workloadType.getOpenWorkloadAt(i)))
						return false;
					}
				catch (Exception e)
					{
					return false;
					}
				}
			}
		if (!this.hasClosedWorkload() && workloadType.hasClosedWorkload())
			return false;
		if (this.hasClosedWorkload() && !workloadType.hasClosedWorkload())
			return false;
		if (this.hasClosedWorkload() && workloadType.hasClosedWorkload())
			{
			try {
				if (!this.getClosedWorkload().equals(workloadType.getClosedWorkload()))
					return false;
				}
			catch (Exception e)
				{
				return false;
				}
			}
		return true;
		}
	}
