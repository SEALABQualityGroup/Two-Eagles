/**
 * TransitType.java
 *
 * This file was generated by XMLSPY 5 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSPY Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package pack.model.schema;

import pack.model.altova.xml.types.SchemaIDRef;

/**
 * TransitType viene utilizzato per specificare le probabilità  di routing.
 * <pre>
 * <code>
 * &lt;xsd:complexType name="TransitType"&gt;
 * 	&lt;!--
 * 	- To: è il nome del nodo destinazione presente
 * 	nell'elemento Transit.
 * 	--&gt;
 * 	&lt;xsd:attribute name="To" type="xsd:IDREF" use="required"/&gt;
 * 	&lt;!--
 * 	- Probability: è la probabilità  di transizione da un nodo all'altro assegnata ad una
 * 	ServiceRequest mediante l'elemento Transit presente nei tre tipi di richieste di servizio
 * 	(TimeServiceRequest, DemandServiceRequest e WorkUnitServiceRequest).
 * 	--&gt;
 * 	&lt;xsd:attribute name="Probability" type="nonNegativeFloat" use="required"/&gt;
 * &lt;/xsd:complexType&gt;
 * </code>
 * </pre>
 *
 * @author Mirko Email: <a href="mailto:mirkoflamminj@virgilio.it">mirkoflamminj@virgilio.it</a>
 * @version 1.0
 */
public class TransitType 
	extends pack.model.altova.xml.Node
	{

	private static final long serialVersionUID = 1L;
	
	public TransitType() {
		super();
	}

	public TransitType(TransitType node) {
		super(node);
	}

	public TransitType(org.w3c.dom.Node node) {
		super(node);
	}

	public TransitType(org.w3c.dom.Document doc) {
		super(doc);
	}
	
	public int getToMinCount() {
		return 1;
	}

	public int getToMaxCount() {
		return 1;
	}

	public int getToCount() {
		return getDomChildCount(Attribute, null, "To");
	}

	public boolean hasTo() {
		return hasDomChild(Attribute, null, "To");
	}

	public SchemaIDRef getToAt(int index) throws Exception {
		return new SchemaIDRef(getDomNodeValue(getDomChildAt(Attribute, null, "To", index)));
	}

	public SchemaIDRef getTo() throws Exception {
		return getToAt(0);
	}

	public void removeToAt(int index) {
		removeDomChildAt(Attribute, null, "To", index);
	}

	public void removeTo() {
		while (hasTo())
			removeToAt(0);
	}

	public void addTo(SchemaIDRef value) {
		setDomChild(Attribute, null, "To", value.toString());
	}

	public void addTo(String value) throws Exception {
		addTo(new SchemaIDRef(value));
	}

	public void insertToAt(SchemaIDRef value, int index) {
		insertDomChildAt(Attribute, null, "To", index, value.toString());
	}

	public void insertToAt(String value, int index) throws Exception {
		insertToAt(new SchemaIDRef(value), index);
	}

	public void replaceToAt(SchemaIDRef value, int index) {
		replaceDomChildAt(Attribute, null, "To", index, value.toString());
	}

	public void replaceToAt(String value, int index) throws Exception {
		replaceToAt(new SchemaIDRef(value), index);
	}

	public int getProbabilityMinCount() {
		return 1;
	}

	public int getProbabilityMaxCount() {
		return 1;
	}

	public int getProbabilityCount() {
		return getDomChildCount(Attribute, null, "Probability");
	}

	public boolean hasProbability() {
		return hasDomChild(Attribute, null, "Probability");
	}

	public nonNegativeFloat getProbabilityAt(int index) throws Exception {
		return new nonNegativeFloat(getDomNodeValue(getDomChildAt(Attribute, null, "Probability", index)));
	}

	public nonNegativeFloat getProbability() throws Exception {
		return getProbabilityAt(0);
	}

	public void removeProbabilityAt(int index) {
		removeDomChildAt(Attribute, null, "Probability", index);
	}

	public void removeProbability() {
		while (hasProbability())
			removeProbabilityAt(0);
	}

	public void addProbability(nonNegativeFloat value) {
		setDomChild(Attribute, null, "Probability", value.toString());
	}

	public void addProbability(String value) throws Exception {
		addProbability(new nonNegativeFloat(value));
	}

	public void insertProbabilityAt(nonNegativeFloat value, int index) {
		insertDomChildAt(Attribute, null, "Probability", index, value.toString());
	}

	public void insertProbabilityAt(String value, int index) throws Exception {
		insertProbabilityAt(new nonNegativeFloat(value), index);
	}

	public void replaceProbabilityAt(nonNegativeFloat value, int index) {
		replaceDomChildAt(Attribute, null, "Probability", index, value.toString());
	}

	public void replaceProbabilityAt(String value, int index) throws Exception {
		replaceProbabilityAt(new nonNegativeFloat(value), index);
	}
	
	@Override
	public boolean equals(Object obj)
		{
		if (!(obj instanceof TransitType))
			return false;
		TransitType transitType = (TransitType)obj;
		if (!this.hasTo() && transitType.hasTo())
			return false;
		if (this.hasTo() && !transitType.hasTo())
			return false;
		if (this.hasTo() && transitType.hasTo())
			{
			try {
				if (!this.getTo().asString().equals(transitType.getTo().asString()))
					return false;
				}
			catch (Exception e)
				{
				return false;
				}
			}
		if (!this.hasProbability() && transitType.hasProbability())
			return false;
		if (this.hasProbability() && !transitType.hasProbability())
			return false;
		if (this.hasProbability() && transitType.hasProbability())
			{
			try {
				if (!this.getProbability().asString().equals(transitType.getProbability().asString()))
					return false;
				}
			catch (Exception e)
				{
				return false;
				}
			}
		return true;
		}
	}
